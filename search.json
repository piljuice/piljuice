[{"title":"清代文化史","path":"/2024/09/10/qingcultrue/","content":"清代文化史讨论课资料整理","tags":["文化"],"categories":["通识课程"]},{"title":"mysql基础","path":"/2024/09/06/mysql/","content":"mysql管理（针对windows系统）登陆mysql123mysql -h 主机名 -u 用户名 -p对于本地操作一般为mysql -u root -p 启动mysql服务器 以管理员的身份打开cmd 1net start mysql 关闭mysql服务器1net stop mysql 用户设置创建用户123456CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;username：用户名。host：指定用户可以从哪些主机连接。例如，localhost 仅允许本地连接，% 允许从任何主机连接。password：用户的密码。ex:CREATE USER &#x27;john&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password123&#x27;; 有关用户权限12345678910111213141516171819授予权限：GRANT privileges ON database_name.* TO &#x27;username&#x27;@&#x27;host&#x27;;privileges：所需的权限，如 ALL PRIVILEGES、SELECT、INSERT、UPDATE、DELETE 等。database_name.*：表示对某个数据库或表授予权限。database_name.* 表示对整个数据库的所有表授予权限，database_name.table_name 表示对指定的表授予权限。TO &#x27;username&#x27;@&#x27;host&#x27;：指定授予权限的用户和主机。ex:GRANT ALL PRIVILEGES ON test_db.* TO &#x27;john&#x27;@&#x27;localhost&#x27;;查看权限：SHOW GRANTS FOR &#x27;username&#x27;@&#x27;host&#x27;;撤销权限：REVOKE privileges ON database_name.* FROM &#x27;username&#x27;@&#x27;host&#x27;;修改用户密码：ALTER USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;new_password&#x27;;修改用户主机：可以先将原来的用户删除，再新创立一个用户与目标主机连接即可 管理mysql命令1234567891011121314151617use+数据库名之后所有的操作都是对这个数据库进行操作SHOW DATABASES列出mysql数据管理系统的数据库列表SHOW TABLES对于之前选定的数据库，显示其中的所有表SHOW COLUMNS FROM 数据表显示数据表中的属性，属性信息，主键信息等信息SHOW INDEX FROM 数据表显示数据表的详细索引信息SHOW TABLE STATUS [FROM db_name] [LIKE &#x27;pattern&#x27;] \\G:该命令将输出Mysql数据库管理系统的性能及统计信息。ex:mysql&gt; SHOW TABLE STATUS FROM RUNOOB; # 显示数据库 RUNOOB 中所有表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &#x27;runoob%&#x27;; # 表名以runoob开头的表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &#x27;runoob%&#x27;\\G; # 加上 \\G，查询结果按列打印 mysql php 语法 ex php连接mysql 123456789101112131415&lt;?php$servername = &quot;localhost&quot;;$username = &quot;your_username&quot;;$password = &quot;your_password&quot;;$database = &quot;your_database&quot;; // 创建连接$conn = mysqli_connect($servername, $username, $password, $database); // 检测连接if (!$conn) &#123; die(&quot;连接失败: &quot; . mysqli_connect_error());&#125; echo &quot;连接成功&quot;;?&gt; mysql连接创建数据库12345678910111213命令行进行创建CREATE DATABASE 数据库名；使用mysqldland创建数据库(需要注意的是此时应该在未登入状态进行操作)mysqladmin -u your_username -p create your_database其中：-u 参数用于指定 MySQL 用户名。-p 参数表示需要输入密码。create 是执行的操作，表示创建数据库。your_database 是要创建的数据库的名称。举例：[root@host]# mysqladmin -u root -p create RUNOOBEnter password:****** 删除数据库1234567drop命令删除数据库DROP DATABASE &lt;database_name&gt;; -- 直接删除数据库，不检查是否存在或DROP DATABASE [IF EXISTS] &lt;database_name&gt;;使用mysqladmin命令删除数据库mysqladmin -u your_username -p drop your_database mysql数据类型12345678910111213141516171819202122232425262728数值类型TINYINT 小整数型 1byteSMALLINT 大整数值 2byteMEDIUMINT 大整数值 3byteINT 大整数值 4byteBIGINT 极大整数值 8byteFLOAT 4byte 单精度浮点值DOUBLE 8byte 双精度浮点值DECIMAL 依赖于M和D的值 小数值日期和时间类型DATE 日期值TIME 时间值或持续时间YEAR 年份DATETIME 混合时间TIMESTAMP 时间戳字符串类型CHAR 定长字符串VARCHAR 变长字符串TINYBLOB 不超过255个字符的短文本字符串TINYTEXT 短文本字符串BLOB 二进制型长文本字符串TEXT 长文本字符串MEDIUMBLOB 二进制形式的中等长度文本数据MEDIUMTEXT 中等长度文本数据LONGBLOBLONGTEXT","tags":["java"],"categories":["技术"]},{"title":"数据结构及方法","path":"/2024/08/26/javadata/","content":"java内置常见方法List类12345678910111213在 Java 中，List&lt;Integer&gt; 的常用方法包括：get(int index): 获取指定索引处的元素。set(int index, Integer element): 替换指定索引处的元素。remove(int index): 删除指定索引处的元素。size(): 返回列表中的元素数量。isEmpty(): 检查列表是否为空。clear(): 清空列表中的所有元素。contains(Object o): 检查列表是否包含指定的元素。indexOf(Object o): 返回第一次出现指定元素的索引。subList(int fromIndex, int toIndex): 获取指定范围内的子列表。toArray(): 转换为数组。clone(): 适用于一维数组 Stringbuilder(处理大量字符串时可以使用)123456789101112131415161718192021222324252627282930313233 创建 StringBuilder 对象StringBuilder sb = new StringBuilder();可以选择在构造函数中传入初始字符串：StringBuilder sb = new StringBuilder(&quot;Initial String&quot;);2. 添加字符串使用 append() 方法向 StringBuilder 对象添加内容：sb.append(&quot;Hello&quot;);sb.append(&quot; &quot;);sb.append(&quot;World&quot;);3. 插入字符串使用 insert() 方法可以在指定位置插入字符串：sb.insert(5, &quot;Awesome &quot;);在这种情况下，将在位置5之前插入字符串&quot;Awesome &quot;。4. 删除字符串使用 delete() 方法可以删除指定位置范围内的字符串：sb.delete(5, 13);这将从位置5开始删除8个字符(13-5).5. 替换字符串使用 replace() 方法可以替换指定位置范围内的字符串：sb.replace(5, 12, &quot;Goodbye&quot;);这将从位置5到12之间的字符串替换为&quot;Goodbye&quot;.6. 反转字符串使用 reverse() 方法可以反转 StringBuilder 对象中的内容：sb.reverse();7. 获取字符串使用 toString() 方法可以将 StringBuilder 对象转换为 String 类型：String result = sb.toString();8. 获取长度和容量length() 方法用于获取当前字符序列的长度。capacity() 方法用于获取 StringBuilder 对象当前的容量。 String类(字符串处理方式)123456789101112131415161718length(): 返回字符串的长度。charAt(int index): 返回指定索引处的字符。substring(int beginIndex, int endIndex): 返回从 beginIndex 到 endIndex 之间的子字符串。**不包括endIndex**indexOf(String str): 返回指定子字符串第一次出现的位置。lastIndexOf(String str): 返回指定子字符串最后一次出现的位置。contains(CharSequence sequence): 判断字符串是否包含指定的字符序列。startsWith(String prefix): 判断字符串是否以指定前缀开始。endsWith(String suffix): 判断字符串是否以指定后缀结束。replace(CharSequence target, CharSequence replacement): 替换所有出现的指定子字符串。trim(): 去除字符串两端的空白字符。toLowerCase(): 将字符串转换为小写。toUpperCase(): 将字符串转换为大写。split(String regex): 根据正则表达式分割字符串。concat(String str): 将指定字符串连接到当前字符串的末尾。equals(Object anObject): 比较两个字符串的内容是否相同。compareTo(String anotherString): 按字典顺序比较两个字符串。toCharArray(): 字符串转化为字符数组valueOf(): 将整数转化为字符串 hashmap1234567891011121314HashMap 主要方法包括：put(K key, V value): 添加或更新键值对。get(Object key): 获取指定键的值。remove(Object key): 删除指定键的键值对。containsKey(Object key): 检查是否包含指定键。containsValue(Object value): 检查是否包含指定值。keySet(): 返回所有键的集合。values(): 返回所有值的集合。entrySet(): 返回所有键值对的集合。size(): 返回映射中键值对的数量。clear(): 清空映射。getOrDefault(K key, V defaultValue) 是 Java Map 接口中的一个方法，用于在指定键不存在时提供一个默认值。它的作用是：如果指定的键存在于映射中：返回与该键关联的值。如果指定的键不存在于映射中：返回提供的默认值。 hashset12345678910111213141516添加元素add(E e): 添加元素 e 到 HashSet 中。如果集合中已存在该元素，返回 false。删除元素remove(Object o): 从集合中移除元素 o。如果集合中存在该元素，返回 true。检查元素contains(Object o): 检查集合是否包含元素 o。如果包含，返回 true。集合大小size(): 返回集合中的元素个数。清空集合clear(): 移除集合中的所有元素。检查是否为空isEmpty(): 检查集合是否为空。如果为空，返回 true。遍历集合iterator(): 返回集合中元素的迭代器。转换为数组toArray(): 返回包含集合中所有元素的数组。可以使用 toArray(T[] a) 方法将集合元素放入指定类型的数组中 Tree（在java中基于红黑树(自平衡的二叉搜索树)）123456789101112131415TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();put(K key, V value)：添加键值对。get(Object key)：根据键获取值。remove(Object key)：移除指定的键值对。firstKey()：获取最小键。lastKey()：获取最大键。headMap(K toKey)：获取小于 toKey 的子映射。tailMap(K fromKey)：获取大于等于 fromKey 的子映射。TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();add(E e)：添加元素。remove(Object o)：移除元素。first()：获取第一个（最小的）元素。last()：获取最后一个（最大的）元素。headSet(E toElement)：获取小于 toElement 的子集。tailSet(E fromElement)：获取大于等于 fromElement 的子集。 优先队列1234567891011121314151617181920212223242526创建 PriorityQueue无参构造函数：创建一个空的优先队列，使用自然顺序（如果元素实现了 Comparable 接口）。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();指定初始容量：创建一个具有指定初始容量的优先队列。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(10); // 初始容量为 10指定比较器：使用自定义的比较器来定义优先级顺序。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); // 大顶堆从现有集合创建：从另一个集合创建优先队列。List&lt;Integer&gt; list = Arrays.asList(3, 1, 4, 1, 5);PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(list);常见内置方法add(E e) / offer(E e)：添加元素到优先队列中。offer 是 add 的一种安全方式（在某些实现中可能有不同的行为）。pq.add(10);pq.offer(20);peek()：查看优先队列中的第一个元素（即优先级最高的元素），但不移除它。如果队列为空，则返回 null。Integer highestPriority = pq.peek();poll()：移除并返回优先队列中的第一个元素。如果队列为空，则返回 null。Integer highestPriority = pq.poll();remove(Object o)：从优先队列中移除指定的元素。如果元素存在，则返回 true，否则返回 false。pq.remove(10);size()：返回优先队列中元素的数量。int size = pq.size();clear()：移除优先队列中的所有元素。pq.clear();isEmpty()：检查优先队列是否为空。boolean empty = pq.isEmpty(); 栈123456789101112Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();push(E item): 将元素压入栈顶。stack.push(10);stack.push(20);pop(): 移除并返回栈顶的元素。如果栈为空，抛出 EmptyStackException。int top = stack.pop(); // 返回 20peek(): 返回栈顶的元素但不移除它。如果栈为空，抛出 EmptyStackException。int top = stack.peek(); // 返回 10isEmpty(): 检查栈是否为空。boolean empty = stack.isEmpty(); // 返回 falsesize(): 返回栈中的元素数量。int size = stack.size(); // 返回 1 队列1234567891011ArrayDeque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();addFirst(E e)：在队列前端添加元素。addLast(E e)：在队列末端添加元素。removeFirst()：移除并返回队列前端的元素。removeLast()：移除并返回队列末端的元素。peekFirst()：返回队列前端的元素但不移除。peekLast()：返回队列末端的元素但不移除。offerFirst(E e)：在队列前端插入元素，如果队列容量已满，返回 false。offerLast(E e)：在队列末端插入元素，如果队列容量已满，返回 false。pollFirst()：移除并返回队列前端的元素，如果队列为空，返回 null。pollLast()：移除并返回队列末端的元素，如果队列为空，返回 null。 快速幂12345678910private long pow(long x, int n) &#123; long res=1; for(;n&gt;0;n=n/2) &#123; if(n%2&gt;0) res=res*x; x=x*x; &#125; return res; &#125;","tags":["java"],"categories":["算法"]},{"title":"hexo常见问题","path":"/2024/08/26/solvehexo/","content":"常见问题及解决措施Connection reset by 140.82.114.3 port 22 fatal: Could not read from remote repository1. ssh -T git@github.com 一般仍会出现报错 2. ssh -T -p 443 git@ssh.github.com 若显示成功 3. ssh -T git@github.com 显示成功","tags":["建站"],"categories":["技术"]},{"title":"leetcode刷题","path":"/2024/08/26/leetcode/","content":"leetcode记录滑动窗口209 长度最小的子数组（中等） 最开始利用java语言尝试用暴力法进行解决但是运行超时，现在准备用滑动窗口的思路进行解决。 解决此问题的大体思路是利用双指针的思想，头尾进行向右移动的操作，如果此时的sum&gt;&#x3D;target，则start向右移动，否则end向右移动。 123456789101112131415161718192021222324252627import java.util.List;import java.util.ArrayList;class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n=nums.length; int start=0;int end=0; int sum=nums[0]; int ans=1;int flag=0;int min=1000000; while(true) &#123; if(sum&gt;=target) &#123; sum=sum-nums[start];start++;flag=1; if(ans&lt;min) min=ans; if(start&gt;n-1) break; ans--; &#125; else &#123; if(end==n-1) break; end++;sum=sum+nums[end];ans++; &#125; &#125; if(flag==1) return min; else return 0; &#125;&#125; 30 串联所有单词的子串（困难）（参考） 最开始的思路就是从给定的字符串入手一个一个往前找，但是检测到178项时出现超时的情况，只有再进一步结合滑动窗口的特性进行算法的优化。这样的时间复杂度为$o(n^2)$ 改进算法:根据题解可以知道需要利用哈希表加上滑动窗口对算法进行优化 我们首先使用一个哈希表map来记录words中单词与其相应的出现的次数 然后我们可以对于输入的字符串s进行分析，每次进行取长度为mxn的子串 但是这样写出来的程序仍然存在超时的可能，我们可以进行取余的优化 也就是通过单词长度的余数进行分类的区划，在每一个区划中 1234567891011121314151617181920212223242526272829303132import java.util.List;import java.util.ArrayList;import java.lang.StringBuilder;class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int n=s.length(),m=words.length,w=words[0].length(); Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); for(String str:words) map.put(str,map.getOrDefault(str,0)+1); List&lt;Integer&gt; ans=new ArrayList&lt;&gt;(); for(int i=0;i&lt;w;i++) &#123; Map&lt;String,Integer&gt; temp=new HashMap&lt;&gt;(); for(int j=i;j+w&lt;=n;j=j+w) &#123; String cur=s.substring(j,j+w); temp.put(cur,temp.getOrDefault(cur,0)+1); if (j &gt;= i + (m * w)) &#123; int idx = j - m * w; String prev = s.substring(idx, idx + w); if (temp.get(prev) == 1) temp.remove(prev); else temp.put(prev, temp.get(prev) - 1); if (!temp.getOrDefault(prev, 0).equals(map.getOrDefault(prev, 0))) continue; &#125; if(!temp.getOrDefault(cur,0).equals(map.getOrDefault(cur,0))) continue; if(temp.equals(map)) ans.add(j-(m-1)*w); &#125; &#125; return ans;&#125;&#125; 76 最小覆盖子串（困难） 这道题目开始思路比较清晰就是用哈希表储存字符与整数，然后比较着急可能30min写了一个框架 后面又进行debug修改大体能够跑完200个样例，但是出现只有一个字符时出现错误 经过了反反复复的修改漏洞与拉扯 最终完成 但是时间复杂度并不好 时间消耗的主要就放在check方法上面，可以单独使用一个变量来储存此时temp中字母数目，然后提前将temp字母数目储存进行比较即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); char[] array=t.toCharArray(); for(char ch:array) map.put(ch,map.getOrDefault(ch,0)+1); int minn=t.length(); int n=s.length(); char[] array1=s.toCharArray(); Map&lt;Character,Integer&gt; temp=new HashMap&lt;&gt;(); // 首先比较两个长度 if(minn&gt;n) &#123;String result=&quot;&quot;;return result ;&#125; else &#123; for(int i=0;i&lt;minn;i++) &#123; temp.put(array1[i],temp.getOrDefault(array1[i],0)+1); &#125; int startindex=0;int minstart=0;int minend=minn-1;int min=minn;int rflag=0; //如果前minn个能够满足 if(map.equals(temp)) &#123; System.out.println(&#x27;t&#x27;);rflag=1; &#125; else &#123; min=100000000; int i=minn;int ans=minn;int flag=1;int p=0; if(minn&lt;n) &#123; while(true) &#123; temp.put(array1[i],temp.getOrDefault(array1[i],0)+1); ans=i-startindex-1; //如果此时满足覆盖 if(check(map,temp)) &#123; if(rflag==0)//还没有满足覆盖，第一次覆盖则min被赋值 &#123;minend=i;min=ans;&#125; rflag=1; System.out.print(startindex);System.out.println(i); //然后滑动窗口start往前移动 while(startindex&lt;n) &#123; char start=array1[startindex]; temp.put(start,temp.getOrDefault(start,0)-1); startindex++; if(check(map,temp)) &#123; rflag=1; ans--; if(ans&lt;min) &#123; minstart=startindex;minend=i; min=ans; &#125; &#125; else &#123;if(i==n-1) flag=0;i++;break;&#125; &#125; &#125; else &#123; if(i==n-1) break; if(i&lt;n-1) i++; &#125; if(flag==0) break; &#125; &#125; &#125; if(rflag==0) &#123; if(minstart==0&amp;&amp;minend==minn-1) &#123;String result=&quot;&quot;;return result ;&#125; &#125; System.out.print(minstart);System.out.print(minend); String result=s.substring(minstart,minend+1); return result; &#125; &#125; //用来检查两个map是否覆盖 private boolean check(Map&lt;Character,Integer&gt;map1,Map&lt;Character,Integer&gt;map2) &#123; for (Map.Entry&lt;Character, Integer&gt; entry : map1.entrySet()) &#123; Character key = entry.getKey(); Integer value1 = entry.getValue(); // Check if key exists in map2 if (!map2.containsKey(key)) &#123; return false; &#125; // Check if value in map1 is less than value in map2 if (value1 &gt; map2.get(key)) &#123; return false; &#125; &#125; return true; &#125;&#125; 3134 找出唯一性数组的中位数（困难）（参考想法） 根据提示可以使用二分查找与滑动窗口解决这道题目，因为暴力算法消耗时间确实太长 那么我们根据本题，nums数组原来长度假设为n，则二分查找时最开时左处为0，右处为n，当进行二分查找的途中，遇到的第一个x，满足唯一性数组中小于等于x的个数大于等于(m+1)&#x2F;2其中m为唯一性数组的长度，那么x即为需要找到的中位数 由上面的思路可以知道，目前的问题是在如何处理满足条件上面，我们可以通过滑动窗口进行解决 在自己写代码的途中首先是解决check的逻辑，其次在二分上面出现不少错误 然后再经历一个测试样例时发现check对于重复出现的几个数字的逻辑也存在错误，最后终于他妈过了 难受香菇 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int medianOfUniquenessArray(int[] nums) &#123; int n = nums.length; long k = ((long) n * (n + 1) / 2 + 1) / 2; int left = 0; int right = n; while (left + 1 &lt; right) &#123; int mid = (left + right) / 2; if (check(nums, mid, k)) &#123; right = mid; &#125; else &#123; left = mid; &#125; &#125; return right; &#125; private boolean check(int[] nums, int upper, long k) &#123; long cnt = 0; int l = 0; HashMap&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;(); for (int r = 0; r &lt; nums.length; r++) &#123; freq.merge(nums[r], 1, Integer::sum); // 移入右端点 while (freq.size() &gt; upper) &#123; // 窗口内元素过多 int out = nums[l++]; if (freq.merge(out, -1, Integer::sum) == 0) &#123; // 移出左端点 freq.remove(out); &#125; &#125; cnt += r - l + 1; // 右端点固定为 r 时，有 r-l+1 个合法左端点 if (cnt &gt;= k) &#123; return true; &#125; &#125; return false; &#125;&#125; 2024 考试最大困扰度（中等）（参考想法） 这道题是一道很隐蔽的滑动窗口的题目 最终参考了大神的想法，实际上就是求区间的长度，然后若想要区间最长，那么区间中包括的非法字符应该尽可能达到k，当达到k以后就可以移动start，直到区间中非法字符数小于k 1234567891011121314151617181920class Solution &#123; public int maxConsecutiveAnswers(String answerKey, int k) &#123; return Math.max(maxtwo(answerKey,k,&#x27;T&#x27;),maxtwo(answerKey,k,&#x27;F&#x27;)); &#125; public int maxtwo(String answerKey,int k,char ch) &#123; int n=answerKey.length(); char[] array=new char[n]; array=answerKey.toCharArray(); int start=0;int ans=0;int sum=0; for(int i=0;i&lt;n;i++) &#123; sum+=array[i]!=ch?1:0; while(sum&gt;k) &#123;sum-=array[start++] !=ch?1:0;&#125; ans=Math.max(ans,i-start+1); &#125; return ans; &#125;&#125; 动态规划 核心：动态规划的核心是将复杂问题拆解成更简单的子问题，通过保存子问题的解来避免重复计算，从而提高效率 3259 最大化的能量（中等）3144 分割字符频率相同的最小字符串（中等）（借鉴思路） 因为观察可以知道原字符串的长度最大为1000，则时间复杂度$n^2$应该是可行的 平衡的代码书写较为容易但是怎样计算最小的算法存在问题 动态规划问题还是掌握的不清楚 在这个问题中我们用一个数组d[]来记录表示当前从0到i的子串的分割字符频率相同的最小字符串的数量 那么计算d[i]时，便可以利用dp得到d[i]&#x3D;min{d[i],d[j-1]+1}（如果j和i之间是平衡子串） 而如何判断平衡子串呢，又需要用一个非常巧妙的思路，没有必要每一次都用哈希表进行存储 12345678910111213141516171819202122class Solution &#123; static final int INF = 0x3f3f3f3f; public int minimumSubstringsInPartition(String s) &#123; int n = s.length(); int[] d = new int[n + 1]; Arrays.fill(d, INF); d[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; Map&lt;Character, Integer&gt; occCnt = new HashMap&lt;Character, Integer&gt;(); int maxCnt = 0; for (int j = i; j &gt;= 1; j--) &#123; occCnt.put(s.charAt(j - 1), occCnt.getOrDefault(s.charAt(j - 1), 0) + 1); maxCnt = Math.max(maxCnt, occCnt.get(s.charAt(j - 1))); if (maxCnt * occCnt.size() == (i - j + 1) &amp;&amp; d[j - 1] != INF) &#123; d[i] = Math.min(d[i], d[j - 1] + 1); &#125; &#125; &#125; return d[n]; &#125;&#125; 198 打家劫舍（中等） 题干的大概要求就是对于一个整数数组，我们若选取了某个值以后只能去就不再能加上它的邻居的值，最终需要求取一个最大值 这一道题是一个典型的动态规划，我们可以得到一个动态规划方程dp[i]&#x3D;max(dp[i-1],dp[i-2]+nums[i]) 12345678910111213141516171819class Solution &#123; public int rob(int[] nums) &#123; int n=nums.length; int ans=0; int[] dp=new int[n]; for(int i=0;i&lt;n;i++) &#123; if(i==0) dp[i]=nums[i]; else if(i&gt;=2) dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); else dp[i]=Math.max(dp[i-1],nums[i]); // System.out.println(dp[i]); &#125; return dp[n-1]; &#125;&#125; 279 完全平方数（中等） 这道题其实就是对于一个数将它拆解成若干完全平方数相加，求完全平方数的个数最少是多少 我使用了动态规划的思想，就是对于i，寻找比i小的平方数t，然后dp[i]&#x3D;min(dp[i],dp[i-t]+1); 12345678910111213141516171819202122232425262728293031class Solution &#123; public int numSquares(int n) &#123; int ans=0; int[] dp=new int[n+1]; int[] temp=new int[n];int j=0; for(int i=1;i&lt;=n;i++) &#123; if(issquare(i)) &#123;temp[j]=i;j++;&#125; &#125; j--;//j为此时平方数数组的数量 for(int i=1;i&lt;=n;i++) &#123; if(issquare(i)) dp[i]=1; else&#123; dp[i]=10000; for(int j1=j;j1&gt;=0;j1--) &#123; if(temp[j1]&lt;i) dp[i]=Math.min(dp[i],dp[i-temp[j1]]+1); &#125; &#125; &#125; return dp[n]; &#125; public boolean issquare(int num)&#123; int num1; num1=(int)Math.sqrt(num); return num1*num1==num; &#125;&#125; 139 单词划分（中等）（参考思路） 这道题最开始没有联想到动态规划，想要暴力但是不是太好做 后面可以设置boolean []dp的数组进行处理，并且动态规划的方程也比较容易找到 最重要的是合理使用了hashset，以前暂时没有使用过 1234567891011121314151617class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int n=wordDict.size();int n1=s.length(); Set&lt;String&gt; wordDictSet = new HashSet(wordDict); boolean dp[]=new boolean[n1+1]; dp[0]=true; for(int i=1;i&lt;=n1;i++) &#123; for(int j=0;j&lt;i;j++) &#123; if(dp[j]&amp;&amp;wordDictSet.contains(s.substring(j,i))) dp[i]=true; &#125; &#125; return dp[n1]; &#125;&#125; 300 最长递增子串（中等） 这道题顾名思义就是对于一个整数数组求得其最长的递增子串的长度 也是很容易联想到用dp进行解决 但是我们每次记录的dp其实是以nums[i]结尾的最长递增子串，所以最终还需要求一个最大值 这也给我们一个提示，动态规划并不一定只按照长度拆分问题，也可以这样拆分 12345678910111213141516171819202122232425262728class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n=nums.length; int[] dp=new int[n]; for(int i=0;i&lt;n;i++) &#123; if(i==0) dp[i]=1; else &#123; dp[i]=1; for(int j=i-1;j&gt;=0;j--) &#123; if(nums[j]&lt;nums[i]) dp[i]=Math.max(dp[i],dp[j]+1); &#125; &#125; // System.out.println(dp[i]); &#125; int max=0; for(int i=0;i&lt;n;i++) &#123; if(dp[i]&gt;max) max=dp[i]; &#125; return max; &#125;&#125; 还可以利用贪心加二分查找法对上述代码进行优化，因为我们想要最终的递增子序列的长度最长对于最终结果的每一个指定长度的子序列的末尾元素都尽可能最小，我们就可以设置一个数组dp[]用于存放递增子序列长度为i+1时的末尾最小元素，我们就可以保证这个数组是递增的，当我们每次更新此数组时就可以利用二分法进行时间的优化。 152 乘积最大子数组（中等） 这一道题看似简单，也可以使用暴力n^2进行解决 后来在评论区发现一个O(n)解决的算法 从左往右遍历时得到一个max,并且如果nums[i]&#x3D;&#x3D;0，ans&#x3D;1，再进行计算 保存上面的max，再从右往左遍历，同样的操作，最终返回max一定为所需要的值 1234567891011121314151617181920class Solution &#123; public int maxProduct(int[] nums) &#123; int a=1; int max=nums[0]; for(int num:nums)&#123; a=a*num; if(max&lt;a)max=a; if(num==0)a=1; &#125; a=1; for(int i=nums.length-1;i&gt;=0;i--)&#123; a=a*nums[i]; if(max&lt;a)max=a; if(nums[i]==0)a=1; &#125; return max; &#125;&#125; 416 分割等和子集（中等）（参考 完全没思路）（二维）补充知识 背包问题1234567* 有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？* 特点：面对每个物品，我们只有选择拿取或者不拿两种选择，不能选择装入某物品的一部分，也不能装入同一物品多次。* 解决办法：声明一个 大小为 m[n][c] 的二维数组，m[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值 ，那么我们可以很容易分析得出 m[i][j] 的计算方法,则可以得到如下状态转化方程if(j&gt;=w[i]) m[i][j]=max(m[i-1][j],m[i-1][j-weight[i]]+value[i]);else m[i][j]=m[i-1][j]; 在针对这道题而言，由官解可以看出，这道题是一个典型的NP问题，不可能存在多项式的解法，则贪心算法遍历降序是错误的 于是把目光聚焦到动态规划 12345678910111213141516171819202122232425262728class Solution &#123; public boolean canPartition(int[] nums) &#123; int n=nums.length; if(n&lt;2) return false; int sum=0,max=0; for(int num:nums) &#123;sum+=num;max=Math.max(max,num);&#125; if(sum%2==1) return false; else&#123; int target=sum/2; if(max&gt;(target)) return false; //考虑转化为背包问题,其中dp[i][j]表示数组0到i是否有元素的和等于j boolean [][] dp=new boolean[n][target+1]; for(int i=0;i&lt;n;i++) dp[i][0]=true; dp[0][nums[0]]=true; for(int i=1;i&lt;n;i++) &#123; for(int j=1;j&lt;=target;j++) &#123; if(nums[i]&gt;j) dp[i][j]=dp[i-1][j]; else dp[i][j]=dp[i-1][j]|dp[i-1][j-nums[i]]; &#125; &#125; return dp[n-1][target]; &#125; &#125;&#125; 5 最长回文子串（中等）（二维） 这道题目确实已经很久没有解决了，去年自己还在用c语言进行暴力求解，结合最近的动态规划问题想到此题也可以用dp来做 结合之前的分割等和子集问题，我联想到可以用二维布尔数组来存储从下标i到下标j的子字符串是否为回文子串 因为如果s[i]&#x3D;&#x3D;s[j]就可以进行回文子串的判断如果(j-i&lt;&#x3D;1)一定为回文子串，否则$dp[i][j]$&#x3D;$dp[i+1][j-1]$ 但是还需要注意遍历顺序，因为我们的递推关系就说明“里面”的字符串比外面先判断 12345678910111213141516171819202122232425262728class Solution &#123; public String longestPalindrome(String s) &#123; int n=s.length(); char[] array=new char[n];array=s.toCharArray(); boolean dp[][]=new boolean[n][n];//对于dp[i][j]表示i到j的子字符串是否为回文子串 for(int i=0;i&lt;n;i++) dp[i][i]=true; int maxlen=0;int rs=0;int re=0; for(int i=n-1;i&gt;=0;i--) &#123; for(int j=i;j&lt;n;j++) &#123; if(array[i]==array[j]) &#123; if(j-i&lt;=1) dp[i][j]=true; else&#123; dp[i][j]=dp[i+1][j-1]; &#125; &#125; if(dp[i][j]&amp;&amp;(j-i+1&gt;maxlen)) &#123; maxlen=j-i+1;rs=i;re=j; &#125; &#125; &#125; return s.substring(rs,re+1); &#125;&#125; 3177 求出最长好序列（二维）（困难）（参考思路） 这道题本来是从每日一题该题的一般版本而来，但是现在我也很讨厌用暴力算法解决问题 考虑过采用动态规划，但是这道题目的突破口是dp到底要维护什么东西，根据大佬的思路 我们需要采用数组来维护遍历到的子序列的最后一个数，与有至多j个相邻不同的子序列的最大长度$dp[i][j]$ 每当我们遍历到x时，我们便存在三种选择。将x选入子序列(又存在两种情况)，不选入x进入子序列 1234567891011121314151617181920212223242526class Solution &#123; public int maximumLength(int[] nums, int k) &#123; int ans = 0; int len = nums.length; int[][] dp = new int[len][51]; for (int i = 0; i &lt; len; i++) &#123; Arrays.fill(dp[i], -1); &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = 1; for (int l = 0; l &lt;= k; l++) &#123; for (int j = 0; j &lt; i; j++) &#123; int add = nums[i] != nums[j] ? 1 : 0; if (l - add &gt;= 0 &amp;&amp; dp[j][l - add] != -1) &#123; dp[i][l] = Math.max(dp[i][l], dp[j][l - add] + 1); &#125; &#125; ans = Math.max(ans, dp[i][l]); &#125; &#125; return ans; &#125;&#125; 1143 最长公共子序列（二维）（中等） 这一道题在一开始因为都是子序列，我有点回忆起了前面的那一道题就是以遍历到的坐标i作为一个dp的自变量 但是因为这道题存在两个字符串进行查找，不难想出用二维的方式$dp[i][j]$用来存储对于text1的在0到i的范围，对于text2在0到j的范围的最长公共子序列的长度 当确定好dp的含义后就可以寻找状态方程，当nums[i]&#x3D;&#x3D;nums[j]时，$dp[i][j]&#x3D;dp[i-1][j-1]+1$ 123456789101112131415161718192021222324252627282930class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int n1=text1.length();int n2=text2.length(); int [][] dp=new int[n1][n2];//记录text1的0到i范围与text2的0到j范围的最长公共子序列 for(int i=0;i&lt;n1;i++) &#123; for(int j=0;j&lt;n2;j++) &#123; if(text1.charAt(i)==text2.charAt(j)) &#123; if(i&gt;0&amp;&amp;j&gt;0) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=1; &#125; else &#123; if(i==0&amp;&amp;j!=0) dp[i][j]=Math.max(0,dp[i][j-1]); else if(j==0&amp;&amp;i!=0) dp[i][j]=Math.max(dp[i-1][j],0); else if(i&gt;0&amp;&amp;j&gt;0) dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]); &#125; //System.out.println(i + &quot;, &quot; + j + &quot;, &quot; + dp[i][j]); &#125; &#125; return dp[n1-1][n2-1]; &#125;&#125; 2552 统计上升数组 开学啦，但是每日一题是不可能停下的(bushi怎么遇到困难了 尴尬喵) 先考虑一下能不能用dp进行处理 字符串3265 统计近似相等数对（中等） 这是一场周赛的题目，当时我作答时最开始使用哈希表思路有误 后面发现可以通过将整数转化为字符串，再将字符串转化为字符数组 然后进行暴力交换进行枚举应该能通过测试，因为这道题的数量级并不是很大 在暴力修改的过程中发现出现问题，最重要的问题就是每个整数都会存在一个前导零，所以交换后可能存在0的情况 一个多小时的缝缝补补，终于结束了，码力还得练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int countPairs(int[] nums) &#123; int n=nums.length; int ans=0; int[][] flag=new int[nums.length][nums.length];//用来记录当前数与后面的数是否已经配对 for(int i=0;i&lt;n;i++) &#123; String temp=String.valueOf(nums[i]); char[] tempch=new char[temp.length()]; tempch=temp.toCharArray(); if(tempch.length&gt;1) &#123; for(int j=0;j&lt;tempch.length-1;j++) &#123; for(int j1=j;j1&lt;tempch.length;j1++) &#123; char[] tempch1=new char[tempch.length]; tempch1=tempch.clone(); char zhong=tempch1[j1]; tempch1[j1]=tempch1[j]; tempch1[j]=zhong; int p=(int)Math.pow(10,tempch1.length-1); int num=0;int t=0; while(p&gt;0) &#123; num=num+(int)(tempch1[t]-&#x27;0&#x27;)*p; t++; p=p/10; &#125; /*for(t=0;t&lt;tempch1.length;t++) System.out.print(tempch1[t]);*/ for(t=0;t&lt;n;t++) if(t!=i&amp;&amp;num==nums[t]&amp;&amp;flag[i][t]==0&amp;&amp;flag[t][i]==0) &#123;ans++;flag[t][i]=1;flag[i][t]=1;System.out.println(num);&#125; &#125; &#125; &#125; else &#123; int num1=nums[i]; int num2=nums[i]*10; for(int t=i+1;t&lt;n;t++) &#123; if(nums[t]==num1||nums[t]==num2) &#123;ans++;flag[t][i]=1;&#125; &#125; &#125; &#125; return ans; &#125; &#125; 树690 员工重要性（中等） 题目要求(给定一个整数 id 表示一个员工的 ID，返回这个员工和他所有下属的重要度的总和。) 容易看出这个数据结构实际上就是一棵树，则需要采用深度优先搜索或者广度优先搜索对这棵树进行遍历即可 但是在操作过程中主要是对题意的id理解有误 后面了解到必须使用哈希表 123456789101112131415161718class Solution &#123; Map&lt;Integer,Employee&gt; map=new HashMap&lt;Integer,Employee&gt;(); public int getImportance(List&lt;Employee&gt; employees, int id) &#123; int total=0; for(Employee em:employees) map.put(em.id,em); Employee pri=map.get(id); return dfs(pri); &#125; private int dfs(Employee em) &#123; int ans=em.importance; for(int i:em.subordinates) ans+=dfs(map.get(i)); return ans; &#125;&#125; 堆3266 k次乘运算后的最终数组（困难）（参考） 这是一道周赛题目,给一个整数数组nums，一个整数k，然后每一次都从nums数组中找到最小的数然后对其乘上一个multipler，然后重复这个过程k次最后输出数组 在这道题的简单版本就直接暴力找到最小值即可，但是时间复杂度较高 为了优化算法就考虑采用小根堆的思想即每一次从堆的顶部直接拿取最小值，进行了multipler再进行下滤操作 但是在502个测试样例的时候即nums的长度为1，但是输入的k十分大，这就导致最终输出的结果出现问题 进一步优化算法：首先手动模拟直到原来的num的最大值已经成为现在的最小值 此后每次的最小元素进行multipler乘操作之后都会变成最大元素，所以在此后的每连续的n次操作中每一个元素都恰好进行一次操作 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; private static final int MOD = 1_000_000_007; public int[] getFinalState(int[] nums, int k, int multiplier) &#123; if (multiplier == 1) &#123; return nums; &#125; int n = nums.length; int mx = 0; PriorityQueue&lt;long[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1])); for(int i=0;i&lt;n;i++) &#123; mx=Math.max(mx,nums[i]); pq.offer(new long[]&#123;nums[i],i&#125;); &#125; for(;k&gt;0&amp;&amp;pq.peek()[0]&lt;mx;k--) &#123; long[] p=pq.poll(); p[0]*=multiplier; pq.offer(p); &#125; for(int i=0;i&lt;n;i++) &#123; long[] p=pq.poll(); nums[(int) p[1]]=(int)(p[0]%MOD*pow(multiplier,k/n+(i&lt;k%n ? 1:0))%MOD); &#125; return nums; &#125; private long pow(long index,int n) &#123; long ans=1; for(;n&gt;0;n=n/2) &#123; if(n%2&gt;0) ans=ans*index%MOD; index=index*index%MOD; &#125; return ans; &#125;&#125; 3275 第K近障碍物查询 这道题本质上就是输入一个数，然后找寻第k小的数 相当于维护一个k个小数的大顶堆 123456789101112131415161718192021222324class Solution &#123; public int[] resultsArray(int[][] queries, int k) &#123; int n = queries.length; int[] results = new int[n]; PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(k, Collections.reverseOrder()); for (int i = 0; i &lt; n; i++) &#123; int distance = Math.abs(queries[i][0]) + Math.abs(queries[i][1]); if (minHeap.size() &lt; k) &#123; minHeap.offer(distance); &#125; else if (distance &lt; minHeap.peek()) &#123; minHeap.poll(); minHeap.offer(distance); &#125; if (minHeap.size() &lt; k) &#123; results[i] = -1; &#125; else &#123; results[i] = minHeap.peek(); &#125; &#125; return results; &#125;&#125; 栈71 简化路径（中等） 这道题其实让我明白并不一定必须使用栈 因为在封装程度较好的java中删除和插入直接使用就行，最好使用强大的api 123456789101112131415161718192021222324252627class Solution &#123; public String simplifyPath(String path) &#123; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); int len = path.length(); for(int i=0;i&lt;len;i++) &#123; if(path.charAt(i)==&#x27;/&#x27;) ; else &#123; int now_index=i; while(i&lt;len&amp;&amp;path.charAt(i)!=&#x27;/&#x27;) i++; String temp1=path.substring(now_index,i); if(temp1.equals(&quot;..&quot;)&amp;&amp;!temp.isEmpty()) temp.remove(temp.size()-1); else if(!temp1.equals(&quot;.&quot;)&amp;&amp;!temp1.equals(&quot;..&quot;)) temp.add(temp1); &#125; &#125; if(temp.isEmpty()) return &quot;/&quot;; StringBuilder sb=new StringBuilder(); for(String str:temp) sb.append(&quot;/&quot;+str); return sb.toString(); &#125;&#125; 32 最长有效括号（困难） 已发布题解在leetcode上面 贪心3273 对Bob造成最小伤害（困难） 这是自己第一次参加双周赛比赛，开始时间比较晚没有时间做这道题 后来下来自己研究发现可以利用数学规律，得到当面对两个选择时可以利用交叉相乘的大小进行比较 最关键的是需要合理利用arrays.sort中的比较接口，现在的java提供下述的lambda表达式 12345678910111213141516171819202122232425class Solution &#123; public long minDamage(int power, int[] damage, int[] health) &#123; long result=0; int n=damage.length; int [][] temp=new int[n][2]; for(int i=0;i&lt;n;i++) &#123; temp[i][0]=damage[i]; temp[i][1]=health[i]/power+((health[i]%power==0)?0:1); &#125; Arrays.sort(temp,(p,q)-&gt;p[0]*q[1]-p[1]*q[0]); long ans1=0; for(int i=0;i&lt;n;i++) &#123; ans1+=temp[i][0]; &#125; for(int i=n-1;i&gt;=0;i--) &#123; result+=(long)(ans1*temp[i][1]); ans1-=temp[i][0]; //System.out.println(temp[i][0]); &#125; return result; &#125;&#125; 枚举2860 让所有学生保持开心的分组（中等） 这道题首先要彻底理解题干的意思，理解好题干后，可以发现一个规律，也就是当一个nums[i]较大的元素被选中后，较小的所有元素一定会被选中 我们可以根据这个规律对数组进行排序，然后就可以根据题意进行解答 1234567891011121314151617181920class Solution &#123; public int countWays(List&lt;Integer&gt; nums) &#123; int n=nums.size(); int ans=0; int[] array=new int[n]; for(int i=0;i&lt;n;i++) array[i]=nums.get(i); Arrays.sort(array);//当完成排序后若后面的元素被选中，则前面的元素一定会被选中 for(int i=-1;i&lt;n;i++) &#123; if(i==-1) ans+=(((i+1)&lt;array[i+1])?1:0); else if(i==n-1) ans+=(((i+1)&gt;array[i])?1:0); else ans+=(((i+1)&gt;array[i]&amp;&amp;(i+1)&lt;array[i+1])?1:0); &#125; return ans; &#125;&#125; 浏览量：| 访客数：","tags":["java"],"categories":["算法"]},{"title":"java基础学习","path":"/2024/08/26/java/","content":"自学指路very good的自学网站 一部分内容指路一部分java自学内容，但是我发现对于系统学习的内容mkdocs构架的效果略好于hexo 基础知识补充面向对象编程多态 介绍：多态的特性是运行期才能动态决定调用的子类方法 一般是指运行时多态 即方法重写：通过父类引用指向子类对象(设计继承) 然后调用重写的方法 如果在子类的覆写方法的编写过程中如果想要调用父类的被覆写的方法，可以使用super 如果一个父类不希望自己的方法被子类覆写 可以使用关键字 final（如果整个类都不希望被继承 可以在class前加上final） example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main &#123; public static void main(String[] args) &#123; // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] &#123; new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) &#125;; System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income... incomes) &#123; double total = 0; for (Income income: incomes) &#123; total = total + income.getTax(); &#125; return total; &#125;&#125;class Income &#123; protected double income; public Income(double income) &#123; this.income = income; &#125; public double getTax() &#123; return income * 0.1; // 税率10% &#125;&#125;class Salary extends Income &#123; public Salary(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125;class StateCouncilSpecialAllowance extends Income &#123; public StateCouncilSpecialAllowance(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return 0; &#125;&#125; 抽象类 如果父类的方法仅仅只是定义没有实现的必要，其作用就是为了让子类覆盖它，则可以使用抽象类,且同时需要将类抽象化 123abstract class Person &#123; public abstract void run();&#125; 但是上述操作后的类抽象化后无法实例化，但是可以引申出面向抽象编程，如在做算法题中常用的List Map等 接口 与抽象类的最大区别是接口不能定义实例字段 用关键字interface声明一个接口 且其中所有的方法都默认为抽象方法 1234interface Person &#123; void run(); String getName();&#125; 实现接口 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 虽然一个类只能继承一个类，但是一个类可以实现多个接口 接口继承相当于将接口进行扩展 12345678910interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125;//此时的Person相当于有三个抽象方法签名 接口中的default方法，可在接口中定义方法的具体实施 包作用域public 定义为public的class、interface可以被其他任何类访问 定义为public的method、field可以被其他类访问，但前提是有访问相应的class的权利 private 定义为private的method、field访问权限定在了class内部 但是如果一个类还有一个嵌套类，那么这个嵌套类有访问上述private修饰的权限 protected protected用于继承关系，能够被子类以及子类的子类访问 因为在继承中，子类无法访问父类的private字段与方法 package 包作用域是指一个类允许访问一个package中不加修饰的class和method与字段 内部类 要想实例化一个内部类，首先要实例化其外部类，再调用new进行实例化 并且内部类的一个特权是可以修改普通类中的private修饰的东西 但是若这个内部类由static修饰则它不再依附于原来类的一个具体实例，但是仍能访问原来类的private字段与方法 classpath和jarclasspath classpath实际上就是一组目录的集合，来指引系统去哪里找寻对应的class文件 jar包 相当于目录，包含很多.class文件 jar包实际上就是一个zip压缩文件，当我们将文件打包好后压缩成zip文件，再修改后缀为jar即可 模块模块介绍 为了解决jar之间的依赖关系，其中这些模块的标识符以.jmod结尾 编写模块 结构：bin目录存放编译后的class文件，src目录存放原码 其中src目录下多了一个模块描述文件 12345module hello.world &#123;requires java.base; // 可不写，任何模块都会自动引入java.baserequires java.xml;&#125;//只有当书写了上述模块引用关系以后，才能在后续原码中引用模块中的包 利用命令行进行模块操作123456javac -d bin src/module-info.java src/com/itranswarp/sample/*.java//若操作成功，则目录下所有的.java文件被编译并被存储到bin目录下jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .//bin目录下所有的class打包成jarjmod create --class-path hello.jar hello.jmod//将这个jar包转换成模块 打包JRE 在过去所有的class都在一个大的jar中，然后最后的jre内存十分大 但是现在已经进行了模块化，我们就可以通过复制一个jre的方式，并且在复制过程中只需要有用的module即可 异常处理java的异常多线程编程多线程基础 在计算机中，一个任务就叫做一个进程 一个进程可以包含一个或多个线程 java语言内置多线程编程，一个java程序相当于一个JVM进程，此进程用一个主线程实现main()方法，在main()方法内部又可以启动多个线程 创建新线程 此时运行一个java程序进入一个JVM进程，然后用一个主线程实现main()方法 123456public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(); t.start(); // 启动新线程 &#125;&#125; 编写新线程 从Thread派生一个自定义类，然后覆写run() 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.start(); // 启动新线程 &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;start new thread!&quot;); &#125;&#125; 创建Thread时，传入一个Runnable实例 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); // 启动新线程 &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;start new thread!&quot;); &#125;&#125; java8可以利用lambda语句进行简化 12345678ublic class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;start new thread!&quot;); &#125;); t.start(); // 启动新线程 &#125;&#125; 主线程与新线程的执行顺序由操作系统调配 并且一个线程只能调用一次start() 线程的状态状态 new:还没执行的线程 blocked:运行中的线程，因为某些操作被堵塞而挂起 runnable:运行中的线程 waiting:运行中的线程，因为某些操作正在等待(其中timed waiting 因为执行sleep()正在等待计时) terminated:执行完毕 join() 一个线程还可以等待另一个线程结束 12345678910111213// 多线程public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread(() -&gt; &#123; System.out.println(&quot;hello&quot;); &#125;); System.out.println(&quot;start&quot;); t.start(); // 启动t线程 t.join(); // 此处main线程会等待t结束,再执行自身进程 System.out.println(&quot;end&quot;); //则最终的执行情况，主线程先打印start，新线程打印hello，主线程再打印end &#125;&#125; 中断线程interrupt()想要中断线程，需要使用interrupt()方法，然后目标线程会不断检查自己是否是interrupted状态，如果是立刻结束进程 123456789101112131415161718192021222324252627282930313233343536373839// 中断线程public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new MyThread(); t.start(); Thread.sleep(1000); t.interrupt(); // 中断t线程 t.join(); // 等待t线程结束 System.out.println(&quot;end&quot;); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; Thread hello = new HelloThread(); hello.start(); // 启动hello线程 try &#123; hello.join(); // 等待hello线程结束，可能会抛出信号 &#125; catch (InterruptedException e) &#123; System.out.println(&quot;interrupted!&quot;); &#125; hello.interrupt(); &#125;&#125;class HelloThread extends Thread &#123; public void run() &#123; int n = 0; while (!isInterrupted()) &#123; n++; System.out.println(n + &quot; hello!&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; break; &#125; &#125; &#125;&#125; 解释：在主线程中先开启t线程，然后主线程进行休眠，t线程继续启动hello线程，然后进入循环，每隔100ms进行一次循环;当主线程睡眠结束它对t线程发出终止信号，此时t线程正在等待hello进程结束，现在它捕捉到终止信息开始打印，并向hello线程发出终止信号，而同时t线程结束，最初的主线程进行打印 设置标志位 类似于面向对象中的一个参数，然后引用此参数作为循环的判定操作，再在主线程中对其进行控制 而这个标志位实际上是线程之间共享的变量(running)，需要在前面用关键字volatile修饰 而这个关键字的作用是告诉主内存，每次访问变量时总能获取主内存最新值，每次修改变量时立马修改回主内存中 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; HelloThread t = new HelloThread(); t.start(); Thread.sleep(1); t.running = false; // 标志位置为false &#125;&#125;class HelloThread extends Thread &#123; public volatile boolean running = true; public void run() &#123; int n = 0; while (running) &#123; n ++; System.out.println(n + &quot; hello!&quot;); &#125; System.out.println(&quot;end!&quot;); &#125;&#125; 守护线程 浏览量：| 访客数：","tags":["java"],"categories":["技术"]}]