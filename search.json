[{"title":"数据结构及方法","path":"/2024/08/26/javadata/","content":"java内置常见方法List类12345678910111213在 Java 中，List&lt;Integer&gt; 的常用方法包括：get(int index): 获取指定索引处的元素。set(int index, Integer element): 替换指定索引处的元素。remove(int index): 删除指定索引处的元素。size(): 返回列表中的元素数量。isEmpty(): 检查列表是否为空。clear(): 清空列表中的所有元素。contains(Object o): 检查列表是否包含指定的元素。indexOf(Object o): 返回第一次出现指定元素的索引。subList(int fromIndex, int toIndex): 获取指定范围内的子列表。toArray(): 转换为数组。clone(): 适用于一维数组 Stringbuilder(处理大量字符串时可以使用)123456789101112131415161718192021222324252627282930313233 创建 StringBuilder 对象StringBuilder sb = new StringBuilder();可以选择在构造函数中传入初始字符串：StringBuilder sb = new StringBuilder(&quot;Initial String&quot;);2. 添加字符串使用 append() 方法向 StringBuilder 对象添加内容：sb.append(&quot;Hello&quot;);sb.append(&quot; &quot;);sb.append(&quot;World&quot;);3. 插入字符串使用 insert() 方法可以在指定位置插入字符串：sb.insert(5, &quot;Awesome &quot;);在这种情况下，将在位置5之前插入字符串&quot;Awesome &quot;。4. 删除字符串使用 delete() 方法可以删除指定位置范围内的字符串：sb.delete(5, 13);这将从位置5开始删除8个字符(13-5).5. 替换字符串使用 replace() 方法可以替换指定位置范围内的字符串：sb.replace(5, 12, &quot;Goodbye&quot;);这将从位置5到12之间的字符串替换为&quot;Goodbye&quot;.6. 反转字符串使用 reverse() 方法可以反转 StringBuilder 对象中的内容：sb.reverse();7. 获取字符串使用 toString() 方法可以将 StringBuilder 对象转换为 String 类型：String result = sb.toString();8. 获取长度和容量length() 方法用于获取当前字符序列的长度。capacity() 方法用于获取 StringBuilder 对象当前的容量。 String类(字符串处理方式)123456789101112131415161718length(): 返回字符串的长度。charAt(int index): 返回指定索引处的字符。substring(int beginIndex, int endIndex): 返回从 beginIndex 到 endIndex 之间的子字符串。**不包括endIndex**indexOf(String str): 返回指定子字符串第一次出现的位置。lastIndexOf(String str): 返回指定子字符串最后一次出现的位置。contains(CharSequence sequence): 判断字符串是否包含指定的字符序列。startsWith(String prefix): 判断字符串是否以指定前缀开始。endsWith(String suffix): 判断字符串是否以指定后缀结束。replace(CharSequence target, CharSequence replacement): 替换所有出现的指定子字符串。trim(): 去除字符串两端的空白字符。toLowerCase(): 将字符串转换为小写。toUpperCase(): 将字符串转换为大写。split(String regex): 根据正则表达式分割字符串。concat(String str): 将指定字符串连接到当前字符串的末尾。equals(Object anObject): 比较两个字符串的内容是否相同。compareTo(String anotherString): 按字典顺序比较两个字符串。toCharArray(): 字符串转化为字符数组valueOf(): 将整数转化为字符串 hashmap1234567891011121314HashMap 主要方法包括：put(K key, V value): 添加或更新键值对。get(Object key): 获取指定键的值。remove(Object key): 删除指定键的键值对。containsKey(Object key): 检查是否包含指定键。containsValue(Object value): 检查是否包含指定值。keySet(): 返回所有键的集合。values(): 返回所有值的集合。entrySet(): 返回所有键值对的集合。size(): 返回映射中键值对的数量。clear(): 清空映射。getOrDefault(K key, V defaultValue) 是 Java Map 接口中的一个方法，用于在指定键不存在时提供一个默认值。它的作用是：如果指定的键存在于映射中：返回与该键关联的值。如果指定的键不存在于映射中：返回提供的默认值。 Tree（在java中基于红黑树(自平衡的二叉搜索树)）123456789101112131415TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();put(K key, V value)：添加键值对。get(Object key)：根据键获取值。remove(Object key)：移除指定的键值对。firstKey()：获取最小键。lastKey()：获取最大键。headMap(K toKey)：获取小于 toKey 的子映射。tailMap(K fromKey)：获取大于等于 fromKey 的子映射。TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();add(E e)：添加元素。remove(Object o)：移除元素。first()：获取第一个（最小的）元素。last()：获取最后一个（最大的）元素。headSet(E toElement)：获取小于 toElement 的子集。tailSet(E fromElement)：获取大于等于 fromElement 的子集。 优先队列1234567891011121314151617181920212223242526创建 PriorityQueue无参构造函数：创建一个空的优先队列，使用自然顺序（如果元素实现了 Comparable 接口）。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();指定初始容量：创建一个具有指定初始容量的优先队列。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(10); // 初始容量为 10指定比较器：使用自定义的比较器来定义优先级顺序。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); // 大顶堆从现有集合创建：从另一个集合创建优先队列。List&lt;Integer&gt; list = Arrays.asList(3, 1, 4, 1, 5);PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(list);常见内置方法add(E e) / offer(E e)：添加元素到优先队列中。offer 是 add 的一种安全方式（在某些实现中可能有不同的行为）。pq.add(10);pq.offer(20);peek()：查看优先队列中的第一个元素（即优先级最高的元素），但不移除它。如果队列为空，则返回 null。Integer highestPriority = pq.peek();poll()：移除并返回优先队列中的第一个元素。如果队列为空，则返回 null。Integer highestPriority = pq.poll();remove(Object o)：从优先队列中移除指定的元素。如果元素存在，则返回 true，否则返回 false。pq.remove(10);size()：返回优先队列中元素的数量。int size = pq.size();clear()：移除优先队列中的所有元素。pq.clear();isEmpty()：检查优先队列是否为空。boolean empty = pq.isEmpty(); 快速幂12345678910private long pow(long x, int n) &#123; long res=1; for(;n&gt;0;n=n/2) &#123; if(n%2&gt;0) res=res*x; x=x*x; &#125; return res; &#125;","tags":["java"],"categories":["算法"]},{"title":"hexo常见问题","path":"/2024/08/26/solvehexo/","content":"常见问题及解决措施Connection reset by 140.82.114.3 port 22 fatal: Could not read from remote repository1. ssh -T git@github.com 一般仍会出现报错 2. ssh -T -p 443 git@ssh.github.com 若显示成功 3. ssh -T git@github.com 显示成功","tags":["建站"],"categories":["技术"]},{"title":"leetcode刷题","path":"/2024/08/26/leetcode/","content":"leetcode记录滑动窗口209 长度最小的子数组（中等） 最开始利用java语言尝试用暴力法进行解决但是运行超时，现在准备用滑动窗口的思路进行解决。 解决此问题的大体思路是利用双指针的思想，头尾进行向右移动的操作，如果此时的sum&gt;&#x3D;target，则start向右移动，否则end向右移动。 123456789101112131415161718192021222324252627import java.util.List;import java.util.ArrayList;class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n=nums.length; int start=0;int end=0; int sum=nums[0]; int ans=1;int flag=0;int min=1000000; while(true) &#123; if(sum&gt;=target) &#123; sum=sum-nums[start];start++;flag=1; if(ans&lt;min) min=ans; if(start&gt;n-1) break; ans--; &#125; else &#123; if(end==n-1) break; end++;sum=sum+nums[end];ans++; &#125; &#125; if(flag==1) return min; else return 0; &#125;&#125; 30 串联所有单词的子串（困难） 最开始的思路就是从给定的字符串入手一个一个往前找，但是检测到178项时出现超时的情况，只有再进一步结合滑动窗口的特性进行算法的优化。这样的时间复杂度为$o(n^2)$ 改进算法:根据题解可以知道需要利用哈希表加上滑动窗口对算法进行优化 我们首先使用一个哈希表map来记录words中单词与其相应的出现的次数 然后我们可以对于输入的字符串s进行分析，每次进行取长度为mxn的子串 但是这样写出来的程序仍然存在超时的可能，我们可以进行取余的优化 也就是通过单词长度的余数进行分类的区划，在每一个区划中 1234567891011121314151617181920212223242526272829303132import java.util.List;import java.util.ArrayList;import java.lang.StringBuilder;class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int n=s.length(),m=words.length,w=words[0].length(); Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); for(String str:words) map.put(str,map.getOrDefault(str,0)+1); List&lt;Integer&gt; ans=new ArrayList&lt;&gt;(); for(int i=0;i&lt;w;i++) &#123; Map&lt;String,Integer&gt; temp=new HashMap&lt;&gt;(); for(int j=i;j+w&lt;=n;j=j+w) &#123; String cur=s.substring(j,j+w); temp.put(cur,temp.getOrDefault(cur,0)+1); if (j &gt;= i + (m * w)) &#123; int idx = j - m * w; String prev = s.substring(idx, idx + w); if (temp.get(prev) == 1) temp.remove(prev); else temp.put(prev, temp.get(prev) - 1); if (!temp.getOrDefault(prev, 0).equals(map.getOrDefault(prev, 0))) continue; &#125; if(!temp.getOrDefault(cur,0).equals(map.getOrDefault(cur,0))) continue; if(temp.equals(map)) ans.add(j-(m-1)*w); &#125; &#125; return ans;&#125;&#125; 76 最小覆盖子串（困难）动态规划3259 最大化的能量（中等）字符串3265 统计近似相等数对（中等） 这是一场周赛的题目，当时我作答时最开始使用哈希表思路有误 后面发现可以通过将整数转化为字符串，再将字符串转化为字符数组 然后进行暴力交换进行枚举应该能通过测试，因为这道题的数量级并不是很大 在暴力修改的过程中发现出现问题，最重要的问题就是每个整数都会存在一个前导零，所以交换后可能存在0的情况 一个多小时的缝缝补补，终于结束了，码力还得练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int countPairs(int[] nums) &#123; int n=nums.length; int ans=0; int[][] flag=new int[nums.length][nums.length];//用来记录当前数与后面的数是否已经配对 for(int i=0;i&lt;n;i++) &#123; String temp=String.valueOf(nums[i]); char[] tempch=new char[temp.length()]; tempch=temp.toCharArray(); if(tempch.length&gt;1) &#123; for(int j=0;j&lt;tempch.length-1;j++) &#123; for(int j1=j;j1&lt;tempch.length;j1++) &#123; char[] tempch1=new char[tempch.length]; tempch1=tempch.clone(); char zhong=tempch1[j1]; tempch1[j1]=tempch1[j]; tempch1[j]=zhong; int p=(int)Math.pow(10,tempch1.length-1); int num=0;int t=0; while(p&gt;0) &#123; num=num+(int)(tempch1[t]-&#x27;0&#x27;)*p; t++; p=p/10; &#125; /*for(t=0;t&lt;tempch1.length;t++) System.out.print(tempch1[t]);*/ for(t=0;t&lt;n;t++) if(t!=i&amp;&amp;num==nums[t]&amp;&amp;flag[i][t]==0&amp;&amp;flag[t][i]==0) &#123;ans++;flag[t][i]=1;flag[i][t]=1;System.out.println(num);&#125; &#125; &#125; &#125; else &#123; int num1=nums[i]; int num2=nums[i]*10; for(int t=i+1;t&lt;n;t++) &#123; if(nums[t]==num1||nums[t]==num2) &#123;ans++;flag[t][i]=1;&#125; &#125; &#125; &#125; return ans; &#125; &#125; 树690 员工重要性（中等） 题目要求(给定一个整数 id 表示一个员工的 ID，返回这个员工和他所有下属的重要度的总和。) 容易看出这个数据结构实际上就是一棵树，则需要采用深度优先搜索或者广度优先搜索对这棵树进行遍历即可 但是在操作过程中主要是对题意的id理解有误 后面了解到必须使用哈希表 123456789101112131415161718class Solution &#123; Map&lt;Integer,Employee&gt; map=new HashMap&lt;Integer,Employee&gt;(); public int getImportance(List&lt;Employee&gt; employees, int id) &#123; int total=0; for(Employee em:employees) map.put(em.id,em); Employee pri=map.get(id); return dfs(pri); &#125; private int dfs(Employee em) &#123; int ans=em.importance; for(int i:em.subordinates) ans+=dfs(map.get(i)); return ans; &#125;&#125; 堆3266 k次乘运算后的最终数组（困难） 这是一道周赛题目,给一个整数数组nums，一个整数k，然后每一次都从nums数组中找到最小的数然后对其乘上一个multipler，然后重复这个过程k次最后输出数组 在这道题的简单版本就直接暴力找到最小值即可，但是时间复杂度较高 为了优化算法就考虑采用小根堆的思想即每一次从堆的顶部直接拿取最小值，进行了multipler再进行下滤操作 但是在502个测试样例的时候即nums的长度为1，但是输入的k十分大，这就导致最终输出的结果出现问题 进一步优化算法：首先手动模拟直到原来的num的最大值已经成为现在的最小值 此后每次的最小元素进行multipler乘操作之后都会变成最大元素，所以在此后的每连续的n次操作中每一个元素都恰好进行一次操作 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; private static final int MOD = 1_000_000_007; public int[] getFinalState(int[] nums, int k, int multiplier) &#123; if (multiplier == 1) &#123; return nums; &#125; int n = nums.length; int mx = 0; PriorityQueue&lt;long[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1])); for(int i=0;i&lt;n;i++) &#123; mx=Math.max(mx,nums[i]); pq.offer(new long[]&#123;nums[i],i&#125;); &#125; for(;k&gt;0&amp;&amp;pq.peek()[0]&lt;mx;k--) &#123; long[] p=pq.poll(); p[0]*=multiplier; pq.offer(p); &#125; for(int i=0;i&lt;n;i++) &#123; long[] p=pq.poll(); nums[(int) p[1]]=(int)(p[0]%MOD*pow(multiplier,k/n+(i&lt;k%n ? 1:0))%MOD); &#125; return nums; &#125; private long pow(long index,int n) &#123; long ans=1; for(;n&gt;0;n=n/2) &#123; if(n%2&gt;0) ans=ans*index%MOD; index=index*index%MOD; &#125; return ans; &#125;&#125; 浏览量：| 访客数：","tags":["java"],"categories":["算法"]},{"title":"java基础学习","path":"/2024/08/26/java/","content":"自学指路very good的自学网站 一部分内容指路一部分java自学内容，但是我发现对于系统学习的内容mkdocs构架的效果略好于hexo 浏览量：| 访客数：","tags":["java"],"categories":["技术"]}]