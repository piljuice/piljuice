[{"title":"数据结构及方法","path":"/2024/08/26/javadata/","content":"java内置常见方法List类12345678910111213在 Java 中，List&lt;Integer&gt; 的常用方法包括：get(int index): 获取指定索引处的元素。set(int index, Integer element): 替换指定索引处的元素。remove(int index): 删除指定索引处的元素。size(): 返回列表中的元素数量。isEmpty(): 检查列表是否为空。clear(): 清空列表中的所有元素。contains(Object o): 检查列表是否包含指定的元素。indexOf(Object o): 返回第一次出现指定元素的索引。subList(int fromIndex, int toIndex): 获取指定范围内的子列表。toArray(): 转换为数组。clone(): 适用于一维数组 Stringbuilder(处理大量字符串时可以使用)123456789101112131415161718192021222324252627282930313233 创建 StringBuilder 对象StringBuilder sb = new StringBuilder();可以选择在构造函数中传入初始字符串：StringBuilder sb = new StringBuilder(&quot;Initial String&quot;);2. 添加字符串使用 append() 方法向 StringBuilder 对象添加内容：sb.append(&quot;Hello&quot;);sb.append(&quot; &quot;);sb.append(&quot;World&quot;);3. 插入字符串使用 insert() 方法可以在指定位置插入字符串：sb.insert(5, &quot;Awesome &quot;);在这种情况下，将在位置5之前插入字符串&quot;Awesome &quot;。4. 删除字符串使用 delete() 方法可以删除指定位置范围内的字符串：sb.delete(5, 13);这将从位置5开始删除8个字符(13-5).5. 替换字符串使用 replace() 方法可以替换指定位置范围内的字符串：sb.replace(5, 12, &quot;Goodbye&quot;);这将从位置5到12之间的字符串替换为&quot;Goodbye&quot;.6. 反转字符串使用 reverse() 方法可以反转 StringBuilder 对象中的内容：sb.reverse();7. 获取字符串使用 toString() 方法可以将 StringBuilder 对象转换为 String 类型：String result = sb.toString();8. 获取长度和容量length() 方法用于获取当前字符序列的长度。capacity() 方法用于获取 StringBuilder 对象当前的容量。 String类(字符串处理方式)123456789101112131415161718length(): 返回字符串的长度。charAt(int index): 返回指定索引处的字符。substring(int beginIndex, int endIndex): 返回从 beginIndex 到 endIndex 之间的子字符串。**不包括endIndex**indexOf(String str): 返回指定子字符串第一次出现的位置。lastIndexOf(String str): 返回指定子字符串最后一次出现的位置。contains(CharSequence sequence): 判断字符串是否包含指定的字符序列。startsWith(String prefix): 判断字符串是否以指定前缀开始。endsWith(String suffix): 判断字符串是否以指定后缀结束。replace(CharSequence target, CharSequence replacement): 替换所有出现的指定子字符串。trim(): 去除字符串两端的空白字符。toLowerCase(): 将字符串转换为小写。toUpperCase(): 将字符串转换为大写。split(String regex): 根据正则表达式分割字符串。concat(String str): 将指定字符串连接到当前字符串的末尾。equals(Object anObject): 比较两个字符串的内容是否相同。compareTo(String anotherString): 按字典顺序比较两个字符串。toCharArray(): 字符串转化为字符数组valueOf(): 将整数转化为字符串 hashmap1234567891011121314HashMap 主要方法包括：put(K key, V value): 添加或更新键值对。get(Object key): 获取指定键的值。remove(Object key): 删除指定键的键值对。containsKey(Object key): 检查是否包含指定键。containsValue(Object value): 检查是否包含指定值。keySet(): 返回所有键的集合。values(): 返回所有值的集合。entrySet(): 返回所有键值对的集合。size(): 返回映射中键值对的数量。clear(): 清空映射。getOrDefault(K key, V defaultValue) 是 Java Map 接口中的一个方法，用于在指定键不存在时提供一个默认值。它的作用是：如果指定的键存在于映射中：返回与该键关联的值。如果指定的键不存在于映射中：返回提供的默认值。 Tree（在java中基于红黑树(自平衡的二叉搜索树)）123456789101112131415TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();put(K key, V value)：添加键值对。get(Object key)：根据键获取值。remove(Object key)：移除指定的键值对。firstKey()：获取最小键。lastKey()：获取最大键。headMap(K toKey)：获取小于 toKey 的子映射。tailMap(K fromKey)：获取大于等于 fromKey 的子映射。TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();add(E e)：添加元素。remove(Object o)：移除元素。first()：获取第一个（最小的）元素。last()：获取最后一个（最大的）元素。headSet(E toElement)：获取小于 toElement 的子集。tailSet(E fromElement)：获取大于等于 fromElement 的子集。 优先队列1234567891011121314151617181920212223242526创建 PriorityQueue无参构造函数：创建一个空的优先队列，使用自然顺序（如果元素实现了 Comparable 接口）。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();指定初始容量：创建一个具有指定初始容量的优先队列。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(10); // 初始容量为 10指定比较器：使用自定义的比较器来定义优先级顺序。PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); // 大顶堆从现有集合创建：从另一个集合创建优先队列。List&lt;Integer&gt; list = Arrays.asList(3, 1, 4, 1, 5);PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(list);常见内置方法add(E e) / offer(E e)：添加元素到优先队列中。offer 是 add 的一种安全方式（在某些实现中可能有不同的行为）。pq.add(10);pq.offer(20);peek()：查看优先队列中的第一个元素（即优先级最高的元素），但不移除它。如果队列为空，则返回 null。Integer highestPriority = pq.peek();poll()：移除并返回优先队列中的第一个元素。如果队列为空，则返回 null。Integer highestPriority = pq.poll();remove(Object o)：从优先队列中移除指定的元素。如果元素存在，则返回 true，否则返回 false。pq.remove(10);size()：返回优先队列中元素的数量。int size = pq.size();clear()：移除优先队列中的所有元素。pq.clear();isEmpty()：检查优先队列是否为空。boolean empty = pq.isEmpty(); 快速幂12345678910private long pow(long x, int n) &#123; long res=1; for(;n&gt;0;n=n/2) &#123; if(n%2&gt;0) res=res*x; x=x*x; &#125; return res; &#125;","tags":["java"],"categories":["算法"]},{"title":"hexo常见问题","path":"/2024/08/26/solvehexo/","content":"常见问题及解决措施Connection reset by 140.82.114.3 port 22 fatal: Could not read from remote repository1. ssh -T git@github.com 一般仍会出现报错 2. ssh -T -p 443 git@ssh.github.com 若显示成功 3. ssh -T git@github.com 显示成功","tags":["建站"],"categories":["技术"]},{"title":"leetcode刷题","path":"/2024/08/26/leetcode/","content":"leetcode记录滑动窗口209 长度最小的子数组（中等） 最开始利用java语言尝试用暴力法进行解决但是运行超时，现在准备用滑动窗口的思路进行解决。 解决此问题的大体思路是利用双指针的思想，头尾进行向右移动的操作，如果此时的sum&gt;&#x3D;target，则start向右移动，否则end向右移动。 123456789101112131415161718192021222324252627import java.util.List;import java.util.ArrayList;class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n=nums.length; int start=0;int end=0; int sum=nums[0]; int ans=1;int flag=0;int min=1000000; while(true) &#123; if(sum&gt;=target) &#123; sum=sum-nums[start];start++;flag=1; if(ans&lt;min) min=ans; if(start&gt;n-1) break; ans--; &#125; else &#123; if(end==n-1) break; end++;sum=sum+nums[end];ans++; &#125; &#125; if(flag==1) return min; else return 0; &#125;&#125; 30 串联所有单词的子串（困难） 最开始的思路就是从给定的字符串入手一个一个往前找，但是检测到178项时出现超时的情况，只有再进一步结合滑动窗口的特性进行算法的优化。这样的时间复杂度为$o(n^2)$ 改进算法:根据题解可以知道需要利用哈希表加上滑动窗口对算法进行优化 我们首先使用一个哈希表map来记录words中单词与其相应的出现的次数 然后我们可以对于输入的字符串s进行分析，每次进行取长度为mxn的子串 但是这样写出来的程序仍然存在超时的可能，我们可以进行取余的优化 也就是通过单词长度的余数进行分类的区划，在每一个区划中 1234567891011121314151617181920212223242526272829303132import java.util.List;import java.util.ArrayList;import java.lang.StringBuilder;class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int n=s.length(),m=words.length,w=words[0].length(); Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); for(String str:words) map.put(str,map.getOrDefault(str,0)+1); List&lt;Integer&gt; ans=new ArrayList&lt;&gt;(); for(int i=0;i&lt;w;i++) &#123; Map&lt;String,Integer&gt; temp=new HashMap&lt;&gt;(); for(int j=i;j+w&lt;=n;j=j+w) &#123; String cur=s.substring(j,j+w); temp.put(cur,temp.getOrDefault(cur,0)+1); if (j &gt;= i + (m * w)) &#123; int idx = j - m * w; String prev = s.substring(idx, idx + w); if (temp.get(prev) == 1) temp.remove(prev); else temp.put(prev, temp.get(prev) - 1); if (!temp.getOrDefault(prev, 0).equals(map.getOrDefault(prev, 0))) continue; &#125; if(!temp.getOrDefault(cur,0).equals(map.getOrDefault(cur,0))) continue; if(temp.equals(map)) ans.add(j-(m-1)*w); &#125; &#125; return ans;&#125;&#125; 76 最小覆盖子串（困难） 这道题目开始思路比较清晰就是用哈希表储存字符与整数，然后比较着急可能30min写了一个框架 后面又进行debug修改大体能够跑完200个样例，但是出现只有一个字符时出现错误 经过了反反复复的修改漏洞与拉扯 最终完成 但是时间复杂度并不好 时间消耗的主要就放在check方法上面，可以单独使用一个变量来储存此时temp中字母数目，然后提前将temp字母数目储存进行比较即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Solution &#123; public String minWindow(String s, String t) &#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); char[] array=t.toCharArray(); for(char ch:array) map.put(ch,map.getOrDefault(ch,0)+1); int minn=t.length(); int n=s.length(); char[] array1=s.toCharArray(); Map&lt;Character,Integer&gt; temp=new HashMap&lt;&gt;(); // 首先比较两个长度 if(minn&gt;n) &#123;String result=&quot;&quot;;return result ;&#125; else &#123; for(int i=0;i&lt;minn;i++) &#123; temp.put(array1[i],temp.getOrDefault(array1[i],0)+1); &#125; int startindex=0;int minstart=0;int minend=minn-1;int min=minn;int rflag=0; //如果前minn个能够满足 if(map.equals(temp)) &#123; System.out.println(&#x27;t&#x27;);rflag=1; &#125; else &#123; min=100000000; int i=minn;int ans=minn;int flag=1;int p=0; if(minn&lt;n) &#123; while(true) &#123; temp.put(array1[i],temp.getOrDefault(array1[i],0)+1); ans=i-startindex-1; //如果此时满足覆盖 if(check(map,temp)) &#123; if(rflag==0)//还没有满足覆盖，第一次覆盖则min被赋值 &#123;minend=i;min=ans;&#125; rflag=1; System.out.print(startindex);System.out.println(i); //然后滑动窗口start往前移动 while(startindex&lt;n) &#123; char start=array1[startindex]; temp.put(start,temp.getOrDefault(start,0)-1); startindex++; if(check(map,temp)) &#123; rflag=1; ans--; if(ans&lt;min) &#123; minstart=startindex;minend=i; min=ans; &#125; &#125; else &#123;if(i==n-1) flag=0;i++;break;&#125; &#125; &#125; else &#123; if(i==n-1) break; if(i&lt;n-1) i++; &#125; if(flag==0) break; &#125; &#125; &#125; if(rflag==0) &#123; if(minstart==0&amp;&amp;minend==minn-1) &#123;String result=&quot;&quot;;return result ;&#125; &#125; System.out.print(minstart);System.out.print(minend); String result=s.substring(minstart,minend+1); return result; &#125; &#125; //用来检查两个map是否覆盖 private boolean check(Map&lt;Character,Integer&gt;map1,Map&lt;Character,Integer&gt;map2) &#123; for (Map.Entry&lt;Character, Integer&gt; entry : map1.entrySet()) &#123; Character key = entry.getKey(); Integer value1 = entry.getValue(); // Check if key exists in map2 if (!map2.containsKey(key)) &#123; return false; &#125; // Check if value in map1 is less than value in map2 if (value1 &gt; map2.get(key)) &#123; return false; &#125; &#125; return true; &#125;&#125; 动态规划3259 最大化的能量（中等）字符串3265 统计近似相等数对（中等） 这是一场周赛的题目，当时我作答时最开始使用哈希表思路有误 后面发现可以通过将整数转化为字符串，再将字符串转化为字符数组 然后进行暴力交换进行枚举应该能通过测试，因为这道题的数量级并不是很大 在暴力修改的过程中发现出现问题，最重要的问题就是每个整数都会存在一个前导零，所以交换后可能存在0的情况 一个多小时的缝缝补补，终于结束了，码力还得练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int countPairs(int[] nums) &#123; int n=nums.length; int ans=0; int[][] flag=new int[nums.length][nums.length];//用来记录当前数与后面的数是否已经配对 for(int i=0;i&lt;n;i++) &#123; String temp=String.valueOf(nums[i]); char[] tempch=new char[temp.length()]; tempch=temp.toCharArray(); if(tempch.length&gt;1) &#123; for(int j=0;j&lt;tempch.length-1;j++) &#123; for(int j1=j;j1&lt;tempch.length;j1++) &#123; char[] tempch1=new char[tempch.length]; tempch1=tempch.clone(); char zhong=tempch1[j1]; tempch1[j1]=tempch1[j]; tempch1[j]=zhong; int p=(int)Math.pow(10,tempch1.length-1); int num=0;int t=0; while(p&gt;0) &#123; num=num+(int)(tempch1[t]-&#x27;0&#x27;)*p; t++; p=p/10; &#125; /*for(t=0;t&lt;tempch1.length;t++) System.out.print(tempch1[t]);*/ for(t=0;t&lt;n;t++) if(t!=i&amp;&amp;num==nums[t]&amp;&amp;flag[i][t]==0&amp;&amp;flag[t][i]==0) &#123;ans++;flag[t][i]=1;flag[i][t]=1;System.out.println(num);&#125; &#125; &#125; &#125; else &#123; int num1=nums[i]; int num2=nums[i]*10; for(int t=i+1;t&lt;n;t++) &#123; if(nums[t]==num1||nums[t]==num2) &#123;ans++;flag[t][i]=1;&#125; &#125; &#125; &#125; return ans; &#125; &#125; 树690 员工重要性（中等） 题目要求(给定一个整数 id 表示一个员工的 ID，返回这个员工和他所有下属的重要度的总和。) 容易看出这个数据结构实际上就是一棵树，则需要采用深度优先搜索或者广度优先搜索对这棵树进行遍历即可 但是在操作过程中主要是对题意的id理解有误 后面了解到必须使用哈希表 123456789101112131415161718class Solution &#123; Map&lt;Integer,Employee&gt; map=new HashMap&lt;Integer,Employee&gt;(); public int getImportance(List&lt;Employee&gt; employees, int id) &#123; int total=0; for(Employee em:employees) map.put(em.id,em); Employee pri=map.get(id); return dfs(pri); &#125; private int dfs(Employee em) &#123; int ans=em.importance; for(int i:em.subordinates) ans+=dfs(map.get(i)); return ans; &#125;&#125; 堆3266 k次乘运算后的最终数组（困难） 这是一道周赛题目,给一个整数数组nums，一个整数k，然后每一次都从nums数组中找到最小的数然后对其乘上一个multipler，然后重复这个过程k次最后输出数组 在这道题的简单版本就直接暴力找到最小值即可，但是时间复杂度较高 为了优化算法就考虑采用小根堆的思想即每一次从堆的顶部直接拿取最小值，进行了multipler再进行下滤操作 但是在502个测试样例的时候即nums的长度为1，但是输入的k十分大，这就导致最终输出的结果出现问题 进一步优化算法：首先手动模拟直到原来的num的最大值已经成为现在的最小值 此后每次的最小元素进行multipler乘操作之后都会变成最大元素，所以在此后的每连续的n次操作中每一个元素都恰好进行一次操作 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; private static final int MOD = 1_000_000_007; public int[] getFinalState(int[] nums, int k, int multiplier) &#123; if (multiplier == 1) &#123; return nums; &#125; int n = nums.length; int mx = 0; PriorityQueue&lt;long[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] != b[0] ? Long.compare(a[0], b[0]) : Long.compare(a[1], b[1])); for(int i=0;i&lt;n;i++) &#123; mx=Math.max(mx,nums[i]); pq.offer(new long[]&#123;nums[i],i&#125;); &#125; for(;k&gt;0&amp;&amp;pq.peek()[0]&lt;mx;k--) &#123; long[] p=pq.poll(); p[0]*=multiplier; pq.offer(p); &#125; for(int i=0;i&lt;n;i++) &#123; long[] p=pq.poll(); nums[(int) p[1]]=(int)(p[0]%MOD*pow(multiplier,k/n+(i&lt;k%n ? 1:0))%MOD); &#125; return nums; &#125; private long pow(long index,int n) &#123; long ans=1; for(;n&gt;0;n=n/2) &#123; if(n%2&gt;0) ans=ans*index%MOD; index=index*index%MOD; &#125; return ans; &#125;&#125; 浏览量：| 访客数：","tags":["java"],"categories":["算法"]},{"title":"java基础学习","path":"/2024/08/26/java/","content":"自学指路very good的自学网站 一部分内容指路一部分java自学内容，但是我发现对于系统学习的内容mkdocs构架的效果略好于hexo 基础知识补充面向对象编程多态 介绍：多态的特性是运行期才能动态决定调用的子类方法 一般是指运行时多态 即方法重写：通过父类引用指向子类对象(设计继承) 然后调用重写的方法 如果在子类的覆写方法的编写过程中如果想要调用父类的被覆写的方法，可以使用super 如果一个父类不希望自己的方法被子类覆写 可以使用关键字 final（如果整个类都不希望被继承 可以在class前加上final） example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main &#123; public static void main(String[] args) &#123; // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] &#123; new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) &#125;; System.out.println(totalTax(incomes)); &#125; public static double totalTax(Income... incomes) &#123; double total = 0; for (Income income: incomes) &#123; total = total + income.getTax(); &#125; return total; &#125;&#125;class Income &#123; protected double income; public Income(double income) &#123; this.income = income; &#125; public double getTax() &#123; return income * 0.1; // 税率10% &#125;&#125;class Salary extends Income &#123; public Salary(double income) &#123; super(income); &#125; @Override public double getTax() &#123; if (income &lt;= 5000) &#123; return 0; &#125; return (income - 5000) * 0.2; &#125;&#125;class StateCouncilSpecialAllowance extends Income &#123; public StateCouncilSpecialAllowance(double income) &#123; super(income); &#125; @Override public double getTax() &#123; return 0; &#125;&#125; 抽象类 如果父类的方法仅仅只是定义没有实现的必要，其作用就是为了让子类覆盖它，则可以使用抽象类,且同时需要将类抽象化 123abstract class Person &#123; public abstract void run();&#125; 但是上述操作后的类抽象化后无法实例化，但是可以引申出面向抽象编程，如在做算法题中常用的List Map等 接口 与抽象类的最大区别是接口不能定义实例字段 用关键字interface声明一个接口 且其中所有的方法都默认为抽象方法 1234interface Person &#123; void run(); String getName();&#125; 实现接口 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 虽然一个类只能继承一个类，但是一个类可以实现多个接口 接口继承相当于将接口进行扩展 12345678910interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125;//此时的Person相当于有三个抽象方法签名 接口中的default方法，可在接口中定义方法的具体实施 包作用域public 定义为public的class、interface可以被其他任何类访问 定义为public的method、field可以被其他类访问，但前提是有访问相应的class的权利 private 定义为private的method、field访问权限定在了class内部 但是如果一个类还有一个嵌套类，那么这个嵌套类有访问上述private修饰的权限 protected protected用于继承关系，能够被子类以及子类的子类访问 因为在继承中，子类无法访问父类的private字段与方法 package 包作用域是指一个类允许访问一个package中不加修饰的class和method与字段 内部类 要想实例化一个内部类，首先要实例化其外部类，再调用new进行实例化 并且内部类的一个特权是可以修改普通类中的private修饰的东西 但是若这个内部类由static修饰则它不再依附于原来类的一个具体实例，但是仍能访问原来类的private字段与方法 classpath和jarclasspath classpath实际上就是一组目录的集合，来指引系统去哪里找寻对应的class文件 jar包 相当于目录，包含很多.class文件 jar包实际上就是一个zip压缩文件，当我们将文件打包好后压缩成zip文件，再修改后缀为jar即可 模块模块介绍 为了解决jar之间的依赖关系，其中这些模块的标识符以.jmod结尾 编写模块 结构：bin目录存放编译后的class文件，src目录存放原码 其中src目录下多了一个模块描述文件 12345module hello.world &#123;requires java.base; // 可不写，任何模块都会自动引入java.baserequires java.xml;&#125;//只有当书写了上述模块引用关系以后，才能在后续原码中引用模块中的包 利用命令行进行模块操作123456javac -d bin src/module-info.java src/com/itranswarp/sample/*.java//若操作成功，则目录下所有的.java文件被编译并被存储到bin目录下jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .//bin目录下所有的class打包成jarjmod create --class-path hello.jar hello.jmod//将这个jar包转换成模块 打包JRE 在过去所有的class都在一个大的jar中，然后最后的jre内存十分大 但是现在已经进行了模块化，我们就可以通过复制一个jre的方式，并且在复制过程中只需要有用的module即可 浏览量：| 访客数：","tags":["java"],"categories":["技术"]}]