[{"title":"leetcode刷题","path":"/2024/08/26/leetcode/","content":"leetcode记录滑动窗口209 长度最小的子数组（中等） 最开始利用java语言尝试用暴力法进行解决但是运行超时，现在准备用滑动窗口的思路进行解决。 解决此问题的大体思路是利用双指针的思想，头尾进行向右移动的操作，如果此时的sum&gt;&#x3D;target，则start向右移动，否则end向右移动。 123456789101112131415161718192021222324252627import java.util.List;import java.util.ArrayList;class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int n=nums.length; int start=0;int end=0; int sum=nums[0]; int ans=1;int flag=0;int min=1000000; while(true) &#123; if(sum&gt;=target) &#123; sum=sum-nums[start];start++;flag=1; if(ans&lt;min) min=ans; if(start&gt;n-1) break; ans--; &#125; else &#123; if(end==n-1) break; end++;sum=sum+nums[end];ans++; &#125; &#125; if(flag==1) return min; else return 0; &#125;&#125; 30 串联所有单词的子串（困难） 最开始的思路就是从给定的字符串入手一个一个往前找，但是检测到178项时出现超时的情况，只有再进一步结合滑动窗口的特性进行算法的优化。这样的时间复杂度为$o(n^2)$ 改进算法:根据题解可以知道需要利用哈希表加上滑动窗口对算法进行优化 我们首先使用一个哈希表map来记录words中单词与其相应的出现的次数 然后我们可以对于输入的字符串s进行分析，每次进行取长度为mxn的子串 但是这样写出来的程序仍然存在超时的可能，我们可以进行取余的优化 也就是通过单词长度的余数进行分类的区划，在每一个区划中 1234567891011121314151617181920212223242526272829303132import java.util.List;import java.util.ArrayList;import java.lang.StringBuilder;class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int n=s.length(),m=words.length,w=words[0].length(); Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); for(String str:words) map.put(str,map.getOrDefault(str,0)+1); List&lt;Integer&gt; ans=new ArrayList&lt;&gt;(); for(int i=0;i&lt;w;i++) &#123; Map&lt;String,Integer&gt; temp=new HashMap&lt;&gt;(); for(int j=i;j+w&lt;=n;j=j+w) &#123; String cur=s.substring(j,j+w); temp.put(cur,temp.getOrDefault(cur,0)+1); if (j &gt;= i + (m * w)) &#123; int idx = j - m * w; String prev = s.substring(idx, idx + w); if (temp.get(prev) == 1) temp.remove(prev); else temp.put(prev, temp.get(prev) - 1); if (!temp.getOrDefault(prev, 0).equals(map.getOrDefault(prev, 0))) continue; &#125; if(!temp.getOrDefault(cur,0).equals(map.getOrDefault(cur,0))) continue; if(temp.equals(map)) ans.add(j-(m-1)*w); &#125; &#125; return ans;&#125;&#125; 76 最小覆盖子串（困难）动态规划3259 最大化的能量（中等）字符串3265 统计近似相等数对（中等） 这是一场周赛的题目，当时我作答时最开始使用哈希表思路有误 后面发现可以通过将整数转化为字符串，再将字符串转化为字符数组 然后进行暴力交换进行枚举应该能通过测试，因为这道题的数量级并不是很大 在暴力修改的过程中发现出现问题，最重要的问题就是每个整数都会存在一个前导零，所以交换后可能存在0的情况 一个多小时的缝缝补补，终于结束了，码力还得练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int countPairs(int[] nums) &#123; int n=nums.length; int ans=0; int[][] flag=new int[nums.length][nums.length];//用来记录当前数与后面的数是否已经配对 for(int i=0;i&lt;n;i++) &#123; String temp=String.valueOf(nums[i]); char[] tempch=new char[temp.length()]; tempch=temp.toCharArray(); if(tempch.length&gt;1) &#123; for(int j=0;j&lt;tempch.length-1;j++) &#123; for(int j1=j;j1&lt;tempch.length;j1++) &#123; char[] tempch1=new char[tempch.length]; tempch1=tempch.clone(); char zhong=tempch1[j1]; tempch1[j1]=tempch1[j]; tempch1[j]=zhong; int p=(int)Math.pow(10,tempch1.length-1); int num=0;int t=0; while(p&gt;0) &#123; num=num+(int)(tempch1[t]-&#x27;0&#x27;)*p; t++; p=p/10; &#125; /*for(t=0;t&lt;tempch1.length;t++) System.out.print(tempch1[t]);*/ for(t=0;t&lt;n;t++) if(t!=i&amp;&amp;num==nums[t]&amp;&amp;flag[i][t]==0&amp;&amp;flag[t][i]==0) &#123;ans++;flag[t][i]=1;flag[i][t]=1;System.out.println(num);&#125; &#125; &#125; &#125; else &#123; int num1=nums[i]; int num2=nums[i]*10; for(int t=i+1;t&lt;n;t++) &#123; if(nums[t]==num1||nums[t]==num2) &#123;ans++;flag[t][i]=1;&#125; &#125; &#125; &#125; return ans; &#125; &#125;","tags":["java"],"categories":["算法"]},{"title":"java基础学习","path":"/2024/08/26/java/","content":"自学指路very good的自学网站 一部分内容指路一部分java自学内容，但是我发现对于系统学习的内容mkdocs构架的效果略好于hexo","tags":["java"],"categories":["技术"]}]